// Code generated by protoc-gen-mask, DO NOT EDIT.

package pb

import (
	"strings"

	"go.saastack.io/chaku/errors"
	"go.saastack.io/protos/types"
)

func (o *Customer) MergeFieldMask(mask1, mask2 []string) ([]string, error) {
	for _, v := range mask1 {
		if !ValidCustomerFieldMask(v) {
			return nil, errors.ErrInvalidField
		}
	}
	for _, v := range mask2 {
		if !ValidCustomerFieldMask(v) {
			return nil, errors.ErrInvalidField
		}
	}
	var flag, sub bool
	var mask3, mask4 []string
	mask3 = mask1
	for _, v2 := range mask2 {
		flag = false
		for _, v3 := range mask3 {
			if v2 == v3 {
				flag = true
				break
			}
		}
		if flag == false {
			mask3 = append(mask3, v2)
		}
	}

	for _, v := range mask3 {
		sub = false
		if strings.Contains(v, ".") {
			got := strings.Split(v, ".")
			for _, v1 := range mask3 {
				if v1 == got[0] {
					sub = true
					break
				}
			}
			if sub == false {
				mask4 = append(mask4, v)
			}
		} else {
			mask4 = append(mask4, v)
		}
	}
	return mask4, nil
}

func (o *Customer) Update(src *Customer, mask []string) error {
	if src == nil || o == nil || len(mask) == 0 {
		return nil
	}

	for _, v := range mask {
		if !ValidCustomerFieldMask(v) {
			return errors.ErrInvalidField
		}
	}

	// Field Mask Slices

	for _, m := range mask {

		switch m {

		case "id":
			o.Id = src.Id

		}
	}

	return nil
}

func ValidCustomerFieldMask(path string) bool {

	switch path {

	case "id":
		return true

	}
	return false
}

func CustomerObjectCompare(obj1 *Customer, obj2 *Customer, path string) []string {

	masks := []string{}

	if obj1 == nil && obj2 == nil {
		return masks
	}

	if path != "" {
		path = path + "."
	}

	if obj1.GetId() != obj2.GetId() {
		masks = append(masks, path+"id")
	}

	return masks
}

func (o *ListCustomerResponse) MergeFieldMask(mask1, mask2 []string) ([]string, error) {
	for _, v := range mask1 {
		if !ValidListCustomerResponseFieldMask(v) {
			return nil, errors.ErrInvalidField
		}
	}
	for _, v := range mask2 {
		if !ValidListCustomerResponseFieldMask(v) {
			return nil, errors.ErrInvalidField
		}
	}
	var flag, sub bool
	var mask3, mask4 []string
	mask3 = mask1
	for _, v2 := range mask2 {
		flag = false
		for _, v3 := range mask3 {
			if v2 == v3 {
				flag = true
				break
			}
		}
		if flag == false {
			mask3 = append(mask3, v2)
		}
	}

	for _, v := range mask3 {
		sub = false
		if strings.Contains(v, ".") {
			got := strings.Split(v, ".")
			for _, v1 := range mask3 {
				if v1 == got[0] {
					sub = true
					break
				}
			}
			if sub == false {
				mask4 = append(mask4, v)
			}
		} else {
			mask4 = append(mask4, v)
		}
	}
	return mask4, nil
}

func (o *ListCustomerResponse) Update(src *ListCustomerResponse, mask []string) error {
	if src == nil || o == nil || len(mask) == 0 {
		return nil
	}

	for _, v := range mask {
		if !ValidListCustomerResponseFieldMask(v) {
			return errors.ErrInvalidField
		}
	}

	// Field Mask Slices

	var mask_nodes []string

	var mask_page_info []string

	for _, m := range mask {

		if strings.Contains(m, "nodes.") {
			split := strings.SplitN(m, ".", 2)
			mask_nodes = append(mask_nodes, split[1])
		}

		if strings.Contains(m, "page_info.") {
			split := strings.SplitN(m, ".", 2)
			mask_page_info = append(mask_page_info, split[1])
		}

		switch m {

		case "nodes":
			o.Nodes = src.Nodes

		case "page_info":
			o.PageInfo = src.PageInfo

		}
	}

	if len(mask_nodes) > 0 {

		o.Nodes = src.Nodes

	}

	if len(mask_page_info) > 0 {

		if o.PageInfo == nil {
			o.PageInfo = &types.PageInfo{}
		}
		if src.PageInfo != nil {
			if err := o.PageInfo.Update(src.PageInfo, mask_page_info); err != nil {
				return err
			}
		}

	}

	return nil
}

func ValidListCustomerResponseFieldMask(path string) bool {

	flag := true
	var split []string
	if strings.Contains(path, ".") {
		split = strings.SplitN(path, ".", 2)
		path = split[0]
		flag = false
	}

	switch path {

	case "nodes":
		return flag || ValidCustomerNodeFieldMask(split[1])

	case "page_info":
		return flag || types.ValidPageInfoFieldMask(split[1])

	}
	return false
}

func ListCustomerResponseObjectCompare(obj1 *ListCustomerResponse, obj2 *ListCustomerResponse, path string) []string {

	masks := []string{}

	if obj1 == nil && obj2 == nil {
		return masks
	}

	if path != "" {
		path = path + "."
	}

	if len(obj1.GetNodes()) != len(obj2.GetNodes()) {
		masks = append(masks, path+"nodes")
	}

	masks = append(masks, types.PageInfoObjectCompare(obj1.GetPageInfo(), obj2.GetPageInfo(), path+"page_info")...)

	return masks
}

func (o *CustomerNode) MergeFieldMask(mask1, mask2 []string) ([]string, error) {
	for _, v := range mask1 {
		if !ValidCustomerNodeFieldMask(v) {
			return nil, errors.ErrInvalidField
		}
	}
	for _, v := range mask2 {
		if !ValidCustomerNodeFieldMask(v) {
			return nil, errors.ErrInvalidField
		}
	}
	var flag, sub bool
	var mask3, mask4 []string
	mask3 = mask1
	for _, v2 := range mask2 {
		flag = false
		for _, v3 := range mask3 {
			if v2 == v3 {
				flag = true
				break
			}
		}
		if flag == false {
			mask3 = append(mask3, v2)
		}
	}

	for _, v := range mask3 {
		sub = false
		if strings.Contains(v, ".") {
			got := strings.Split(v, ".")
			for _, v1 := range mask3 {
				if v1 == got[0] {
					sub = true
					break
				}
			}
			if sub == false {
				mask4 = append(mask4, v)
			}
		} else {
			mask4 = append(mask4, v)
		}
	}
	return mask4, nil
}

func (o *CustomerNode) Update(src *CustomerNode, mask []string) error {
	if src == nil || o == nil || len(mask) == 0 {
		return nil
	}

	for _, v := range mask {
		if !ValidCustomerNodeFieldMask(v) {
			return errors.ErrInvalidField
		}
	}

	// Field Mask Slices

	var mask_node []string

	for _, m := range mask {

		if strings.Contains(m, "node.") {
			split := strings.SplitN(m, ".", 2)
			mask_node = append(mask_node, split[1])
		}

		switch m {

		case "position":
			o.Position = src.Position

		case "node":
			o.Node = src.Node

		}
	}

	if len(mask_node) > 0 {

		if o.Node == nil {
			o.Node = &Customer{}
		}
		if src.Node != nil {
			if err := o.Node.Update(src.Node, mask_node); err != nil {
				return err
			}
		}

	}

	return nil
}

func ValidCustomerNodeFieldMask(path string) bool {

	flag := true
	var split []string
	if strings.Contains(path, ".") {
		split = strings.SplitN(path, ".", 2)
		path = split[0]
		flag = false
	}

	switch path {

	case "position":
		return true

	case "node":
		return flag || ValidCustomerFieldMask(split[1])

	}
	return false
}

func CustomerNodeObjectCompare(obj1 *CustomerNode, obj2 *CustomerNode, path string) []string {

	masks := []string{}

	if obj1 == nil && obj2 == nil {
		return masks
	}

	if path != "" {
		path = path + "."
	}

	if obj1.GetPosition() != obj2.GetPosition() {
		masks = append(masks, path+"position")
	}

	masks = append(masks, CustomerObjectCompare(obj1.GetNode(), obj2.GetNode(), path+"node")...)

	return masks
}

func (o *BatchGetCustomerResponse) MergeFieldMask(mask1, mask2 []string) ([]string, error) {
	for _, v := range mask1 {
		if !ValidBatchGetCustomerResponseFieldMask(v) {
			return nil, errors.ErrInvalidField
		}
	}
	for _, v := range mask2 {
		if !ValidBatchGetCustomerResponseFieldMask(v) {
			return nil, errors.ErrInvalidField
		}
	}
	var flag, sub bool
	var mask3, mask4 []string
	mask3 = mask1
	for _, v2 := range mask2 {
		flag = false
		for _, v3 := range mask3 {
			if v2 == v3 {
				flag = true
				break
			}
		}
		if flag == false {
			mask3 = append(mask3, v2)
		}
	}

	for _, v := range mask3 {
		sub = false
		if strings.Contains(v, ".") {
			got := strings.Split(v, ".")
			for _, v1 := range mask3 {
				if v1 == got[0] {
					sub = true
					break
				}
			}
			if sub == false {
				mask4 = append(mask4, v)
			}
		} else {
			mask4 = append(mask4, v)
		}
	}
	return mask4, nil
}

func (o *BatchGetCustomerResponse) Update(src *BatchGetCustomerResponse, mask []string) error {
	if src == nil || o == nil || len(mask) == 0 {
		return nil
	}

	for _, v := range mask {
		if !ValidBatchGetCustomerResponseFieldMask(v) {
			return errors.ErrInvalidField
		}
	}

	// Field Mask Slices

	var mask_customer []string

	for _, m := range mask {

		if strings.Contains(m, "customer.") {
			split := strings.SplitN(m, ".", 2)
			mask_customer = append(mask_customer, split[1])
		}

		switch m {

		case "customer":
			o.Customer = src.Customer

		}
	}

	if len(mask_customer) > 0 {

		emp := make(map[string]*Customer, len(src.Customer))

		for _, em := range src.Customer {
			emp[em.Id] = em
		}
		for _, em := range o.Customer {
			if err := em.Update(emp[em.Id], mask_customer); err != nil {
				return err
			}
		}

	}

	return nil
}

func ValidBatchGetCustomerResponseFieldMask(path string) bool {

	flag := true
	var split []string
	if strings.Contains(path, ".") {
		split = strings.SplitN(path, ".", 2)
		path = split[0]
		flag = false
	}

	switch path {

	case "customer":
		return flag || ValidCustomerFieldMask(split[1])

	}
	return false
}

func BatchGetCustomerResponseObjectCompare(obj1 *BatchGetCustomerResponse, obj2 *BatchGetCustomerResponse, path string) []string {

	masks := []string{}

	if obj1 == nil && obj2 == nil {
		return masks
	}

	if path != "" {
		path = path + "."
	}

	if len(obj1.GetCustomer()) != len(obj2.GetCustomer()) {
		masks = append(masks, path+"customer")
	}

	return masks
}
